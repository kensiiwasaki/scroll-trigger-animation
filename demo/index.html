<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>スクロールトリガーアニメーションデモ</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f5f5f5;
      }

      header {
        background-color: #2c3e50;
        color: white;
        padding: 2rem 0;
        text-align: center;
        position: relative;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 2rem;
      }

      section {
        padding: 5rem 0;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
      }

      h2 {
        font-size: 2rem;
        margin-bottom: 2rem;
        text-align: center;
      }

      p {
        margin-bottom: 1.5rem;
        font-size: 1.1rem;
      }

      .box-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 2rem;
        margin: 3rem 0;
      }

      .box {
        width: 300px;
        height: 200px;
        background-color: #3498db;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .box:nth-child(2) {
        background-color: #e74c3c;
      }

      .box:nth-child(3) {
        background-color: #2ecc71;
      }

      .box:nth-child(4) {
        background-color: #f39c12;
      }

      .box:nth-child(5) {
        background-color: #9b59b6;
      }

      .box:nth-child(6) {
        background-color: #1abc9c;
      }

      .spacer {
        height: 50vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2rem;
        color: #7f8c8d;
        font-style: italic;
      }

      .features {
        display: flex;
        flex-wrap: wrap;
        gap: 2rem;
        justify-content: center;
      }

      .feature {
        flex: 1;
        min-width: 300px;
        background-color: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .feature h3 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: #2c3e50;
      }

      footer {
        background-color: #2c3e50;
        color: white;
        text-align: center;
        padding: 2rem 0;
        margin-top: 3rem;
      }

      /* デバッグ用スタイル */
      .debug-info {
        position: fixed;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 9999;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="container">
        <h1>スクロールトリガーアニメーション</h1>
        <p>
          スクロールに合わせて要素をアニメーションさせるシンプルなライブラリ
        </p>
      </div>
    </header>

    <section>
      <div class="container">
        <h2>基本的なアニメーション</h2>
        <p>
          下にスクロールして、様々なアニメーション効果をご覧ください。各ボックスは異なるアニメーションを使用しています。
        </p>

        <div class="box-container">
          <div class="box" data-animation="fade-in">フェードイン</div>
          <div class="box" data-animation="fade-in-up">下から</div>
          <div class="box" data-animation="fade-in-down">上から</div>
          <div class="box" data-animation="fade-in-left">左から</div>
          <div class="box" data-animation="fade-in-right">右から</div>
          <div class="box" data-animation="zoom-in">ズームイン</div>
        </div>
      </div>
    </section>

    <div class="spacer">↓ 下にスクロールしてください ↓</div>

    <section style="background-color: #ecf0f1">
      <div class="container">
        <h2>特徴</h2>
        <div class="features">
          <div class="feature" data-animation="fade-in-up" data-delay="0">
            <h3>Intersection Observer API</h3>
            <p>
              最新のIntersection Observer
              APIを使用して、スクロール位置を効率的に検知します。これにより、メインスレッドへの負荷を最小限に抑え、スムーズなアニメーションを実現します。
            </p>
          </div>
          <div class="feature" data-animation="fade-in-up" data-delay="200">
            <h3>カスタマイズ可能</h3>
            <p>
              アニメーションの種類、遅延時間、しきい値など、様々なオプションをカスタマイズできます。また、独自のアニメーションを定義することも可能です。
            </p>
          </div>
          <div class="feature" data-animation="fade-in-up" data-delay="400">
            <h3>シンプルなAPI</h3>
            <p>
              使いやすいAPIを提供し、わずか数行のコードで実装できます。既存のCSSフレームワークとも簡単に連携できます。
            </p>
          </div>
        </div>
      </div>
    </section>

    <div class="spacer">↓ もう少し下にスクロールしてください ↓</div>

    <section>
      <div class="container">
        <h2>その他のアニメーション</h2>
        <div class="box-container">
          <div class="box" data-animation="zoom-out">ズームアウト</div>
          <div class="box" data-animation="flip">フリップ</div>
          <div class="box" data-animation="bounce">バウンス</div>
        </div>
      </div>
    </section>

    <footer>
      <div class="container">
        <p>スクロールトリガーアニメーションライブラリ デモページ</p>
      </div>
    </footer>

    <!-- デバッグ情報 -->
    <div class="debug-info" id="debug-info">ライブラリ読み込み中...</div>

    <!-- ライブラリを直接定義 -->
    <script>
      // アニメーションクラス
      class Animations {
        // スタイル要素
        static styleElement = null;

        // 基本スタイルを適用
        static applyBaseStyles() {
          if (!this.styleElement) {
            this.styleElement = document.createElement("style");
            document.head.appendChild(this.styleElement);
          }

          // 基本的なアニメーションスタイル
          const baseStyles = `
            /* アニメーション前の初期状態 */
            .scroll-animate-init {
              opacity: 0;
              transition: opacity 0.6s ease-out, transform 0.6s ease-out;
              will-change: opacity, transform;
            }

            /* アニメーション実行時のスタイル */
            .scroll-animate {
              opacity: 1;
              transform: none;
            }
          `;

          this.styleElement.textContent = baseStyles;
        }

        // フェードインアニメーション
        static fadeIn() {
          this.addAnimation(
            "fade-in",
            `
            .fade-in {
              opacity: 0;
            }
            .fade-in.scroll-animate {
              opacity: 1;
            }
          `
          );
        }

        // 下からフェードインアニメーション
        static fadeInUp() {
          this.addAnimation(
            "fade-in-up",
            `
            .fade-in-up {
              opacity: 0;
              transform: translateY(30px);
            }
            .fade-in-up.scroll-animate {
              opacity: 1;
              transform: translateY(0);
            }
          `
          );
        }

        // 上からフェードインアニメーション
        static fadeInDown() {
          this.addAnimation(
            "fade-in-down",
            `
            .fade-in-down {
              opacity: 0;
              transform: translateY(-30px);
            }
            .fade-in-down.scroll-animate {
              opacity: 1;
              transform: translateY(0);
            }
          `
          );
        }

        // 左からフェードインアニメーション
        static fadeInLeft() {
          this.addAnimation(
            "fade-in-left",
            `
            .fade-in-left {
              opacity: 0;
              transform: translateX(-30px);
            }
            .fade-in-left.scroll-animate {
              opacity: 1;
              transform: translateX(0);
            }
          `
          );
        }

        // 右からフェードインアニメーション
        static fadeInRight() {
          this.addAnimation(
            "fade-in-right",
            `
            .fade-in-right {
              opacity: 0;
              transform: translateX(30px);
            }
            .fade-in-right.scroll-animate {
              opacity: 1;
              transform: translateX(0);
            }
          `
          );
        }

        // ズームインアニメーション
        static zoomIn() {
          this.addAnimation(
            "zoom-in",
            `
            .zoom-in {
              opacity: 0;
              transform: scale(0.8);
            }
            .zoom-in.scroll-animate {
              opacity: 1;
              transform: scale(1);
            }
          `
          );
        }

        // ズームアウトアニメーション
        static zoomOut() {
          this.addAnimation(
            "zoom-out",
            `
            .zoom-out {
              opacity: 0;
              transform: scale(1.2);
            }
            .zoom-out.scroll-animate {
              opacity: 1;
              transform: scale(1);
            }
          `
          );
        }

        // フリップアニメーション
        static flip() {
          this.addAnimation(
            "flip",
            `
            .flip {
              opacity: 0;
              transform: perspective(400px) rotateY(90deg);
            }
            .flip.scroll-animate {
              opacity: 1;
              transform: perspective(400px) rotateY(0);
            }
          `
          );
        }

        // バウンスアニメーション
        static bounce() {
          this.addAnimation(
            "bounce",
            `
            @keyframes scroll-bounce {
              0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
              }
              40% {
                transform: translateY(-20px);
              }
              60% {
                transform: translateY(-10px);
              }
            }
            .bounce {
              opacity: 0;
            }
            .bounce.scroll-animate {
              opacity: 1;
              animation: scroll-bounce 1s;
            }
          `
          );
        }

        // アニメーションスタイルを追加
        static addAnimation(name, css) {
          if (!this.styleElement) {
            this.applyBaseStyles();
          }

          this.styleElement.textContent += css;
        }
      }

      // ScrollTriggerクラス
      class ScrollTrigger {
        constructor(options = {}) {
          this.options = {
            animationClass: "scroll-animate",
            initialClass: "scroll-animate-init",
            delay: 0,
            threshold: 0.1,
            once: true,
            ...options,
          };

          this.observer = null;
          this.elements = new Map();
          this.init();
        }

        // 初期化処理
        init() {
          const observerOptions = {
            root: null, // ビューポートを基準にする
            rootMargin: "0px",
            threshold: this.options.threshold,
          };

          this.observer = new IntersectionObserver(
            this.handleIntersect.bind(this),
            observerOptions
          );
        }

        // 要素が交差したときの処理
        handleIntersect(entries, observer) {
          entries.forEach((entry) => {
            // 要素がビューポートに入った場合
            if (entry.isIntersecting) {
              const element = entry.target;

              // すでにアニメーション済みの要素はスキップ
              if (this.elements.get(element)) return;

              // アニメーション前のコールバックを実行
              if (this.options.onBeforeAnimate) {
                this.options.onBeforeAnimate(element);
              }

              // 遅延時間が設定されている場合は遅延実行
              setTimeout(() => {
                if (this.options.initialClass) {
                  element.classList.remove(this.options.initialClass);
                }

                if (this.options.animationClass) {
                  element.classList.add(this.options.animationClass);
                }

                // アニメーション後のコールバックを実行
                if (this.options.onAfterAnimate) {
                  this.options.onAfterAnimate(element);
                }

                // 一度だけ実行する設定の場合は監視を解除
                if (this.options.once && this.observer) {
                  this.observer.unobserve(element);
                  this.elements.set(element, true);
                }
              }, this.options.delay || 0);
            }
          });
        }

        // 要素を監視対象に追加
        add(elements) {
          const targetElements = [];

          if (typeof elements === "string") {
            // セレクタの場合は要素を取得
            document
              .querySelectorAll(elements)
              .forEach((el) => targetElements.push(el));
          } else if (elements instanceof Element) {
            // 単一要素の場合
            targetElements.push(elements);
          } else if (elements instanceof NodeList || Array.isArray(elements)) {
            // 複数要素の場合
            Array.from(elements).forEach((el) => {
              if (el instanceof Element) targetElements.push(el);
            });
          }

          // 各要素を監視対象に追加
          targetElements.forEach((element) => {
            if (!this.elements.has(element) && this.observer) {
              // 初期クラスを追加
              if (this.options.initialClass) {
                element.classList.add(this.options.initialClass);
              }

              this.observer.observe(element);
              this.elements.set(element, false);
            }
          });
        }

        // 要素の監視を解除
        remove(elements) {
          const targetElements = [];

          if (typeof elements === "string") {
            document
              .querySelectorAll(elements)
              .forEach((el) => targetElements.push(el));
          } else if (elements instanceof Element) {
            targetElements.push(elements);
          } else if (elements instanceof NodeList || Array.isArray(elements)) {
            Array.from(elements).forEach((el) => {
              if (el instanceof Element) targetElements.push(el);
            });
          }

          targetElements.forEach((element) => {
            if (this.observer) {
              this.observer.unobserve(element);
              this.elements.delete(element);
            }
          });
        }

        // すべての要素の監視を解除
        destroy() {
          if (this.observer) {
            this.observer.disconnect();
            this.elements.clear();
            this.observer = null;
          }
        }

        // 監視中の要素を再スキャン
        refresh() {
          this.destroy();
          this.init();
        }
      }
    </script>

    <script>
      // デバッグ情報を表示する関数
      function updateDebugInfo(message) {
        const debugElement = document.getElementById("debug-info");
        if (debugElement) {
          debugElement.textContent = message;
        }
      }

      try {
        updateDebugInfo("ライブラリを初期化中...");

        updateDebugInfo("アニメーションスタイルを適用中...");

        // 基本的なアニメーションスタイルを適用
        Animations.applyBaseStyles();

        // 各種アニメーションを登録
        Animations.fadeIn();
        Animations.fadeInUp();
        Animations.fadeInDown();
        Animations.fadeInLeft();
        Animations.fadeInRight();
        Animations.zoomIn();
        Animations.zoomOut();
        Animations.flip();
        Animations.bounce();

        updateDebugInfo("スクロールトリガーを初期化中...");

        // スクロールトリガーを初期化
        const scrollTrigger = new ScrollTrigger({
          threshold: 0.2,
          once: true,
          onBeforeAnimate: (element) => {
            updateDebugInfo(
              `アニメーション開始: ${element.textContent || element.className}`
            );
          },
          onAfterAnimate: (element) => {
            updateDebugInfo(
              `アニメーション完了: ${element.textContent || element.className}`
            );

            // 3秒後にデバッグ情報をクリア
            setTimeout(() => {
              updateDebugInfo("すべて正常に動作中");
            }, 3000);
          },
        });

        updateDebugInfo("アニメーション要素を設定中...");

        // アニメーション要素を取得して設定
        document.querySelectorAll("[data-animation]").forEach((element) => {
          const animationType = element.getAttribute("data-animation");
          const delay = element.getAttribute("data-delay");

          // アニメーションクラスを追加
          element.classList.add(animationType);

          // 遅延時間が指定されている場合は設定
          if (delay) {
            element.style.transitionDelay = `${delay}ms`;
          }

          // 要素を監視対象に追加
          scrollTrigger.add(element);
        });

        updateDebugInfo(
          "初期化完了。スクロールしてアニメーションをご確認ください。"
        );
      } catch (error) {
        updateDebugInfo(`予期せぬエラーが発生しました: ${error.message}`);
        console.error("予期せぬエラー:", error);
      }
    </script>
  </body>
</html>
